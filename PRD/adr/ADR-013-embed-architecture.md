# ADR-013: Embeddable Form via Script Tag

## Status
Accepted

## Context
FormAgent forms are embedded on external websites -- marketing sites, landing pages, documentation portals -- that are not under FormAgent's control. The embed mechanism must:

- Work on any website with a single code snippet
- Fetch the form schema dynamically (supporting A/B experiments; see [ADR-011](./ADR-011-ab-experimentation.md))
- Render the form from the schema without depending on the host page's CSS or JS frameworks
- Submit data back to the FormAgent server via CORS-enabled POST
- Track field-level interactions (focus, blur, fill events, time spent) for analytics
- Capture UTM parameters, referrer, and page URL for attribution
- Include anti-spam honeypot fields
- Include experiment variant tracking fields
- Display success messages or redirect on submission
- Require no authentication (public endpoints)

The external website operator pastes a snippet into their HTML. The form appears, collects submissions, and sends them to FormAgent. The operator should not need to understand FormAgent's internals.

## Decision
We implement an **embeddable form widget** distributed as a single JavaScript file (`embed.js`) loaded via a script tag.

### Embed Snippet

Generated by the dashboard when the operator clicks "Get Embed Code":

```html
<!-- FormAgent Embed -->
<div id="fa-form-{form_id}"></div>
<script src="https://{host}/embed.js" data-form-id="{form_id}"></script>
```

The operator copies this into their page. The `<div>` is the mount point. The `<script>` tag carries the `data-form-id` attribute identifying which form to render.

### embed.js Behavior

The script executes the following sequence on page load:

1. **Read configuration** from `data-form-id` attribute on its own `<script>` tag
2. **Fetch schema** via `GET /api/forms/{form_id}/schema` (public endpoint, no auth)
   - If an active A/B experiment exists, the server performs weighted variant selection and returns the variant-specific schema with `experiment_id` and `variant_id` metadata
3. **Render form** by dynamically building HTML elements from the field definitions:
   - Maps field types to HTML elements (text -> `<input type="text">`, select -> `<select>`, etc.)
   - Sets labels, placeholders, required attributes, and validation rules
   - Applies inline or scoped CSS (does not pollute host page styles)
4. **Add hidden fields:**
   - Honeypot field (`_hp`) for anti-spam
   - `_experiment_id` and `_variant_id` for A/B tracking
   - UTM parameters captured from URL query string (`utm_source`, `utm_medium`, `utm_campaign`, `utm_content`, `utm_term`)
   - `_referrer` (document.referrer) and `_page_url` (window.location.href)
5. **Attach interaction tracking:**
   - `focus` event on each field -> record focused timestamp
   - `blur` event on each field -> compute time spent, record fill status
   - Build `field_interactions` object: `{field_name: {focused: bool, filled: bool, time_ms: int}}`
6. **On submit:**
   - Validate required fields, type constraints, and length limits client-side
   - If honeypot field has a value, silently discard (do not submit)
   - POST JSON to `POST /api/submissions/{form_id}` with CORS
   - Include `data`, `_meta` (UTM, referrer, page_url), `_hp`, `field_interactions`, `_experiment_id`, `_variant_id`
7. **Handle response:**
   - Success: Display `thank_you_message` from form config, or redirect to `redirect_url`
   - Validation error: Display field-level error messages
   - Rate limit (429): Display rate limit message
   - Server error: Display generic error

### Public Endpoints

These endpoints require no authentication:

| Endpoint | Purpose |
|----------|---------|
| `GET /api/forms/{form_id}/schema` | Fetch form fields + A/B variant |
| `POST /api/submissions/{form_id}` | Submit form data |
| `OPTIONS /api/submissions/{form_id}` | CORS preflight |

The **form ID is the implicit auth boundary**. The form belongs to a workspace (see [ADR-005](./ADR-005-workspace-isolation.md)). The submission inherits the workspace_id from the form. External visitors never see or provide a workspace_id.

### CORS Configuration

The submission endpoint returns CORS headers based on the form's `security.allowed_origins`:

- If `allowed_origins` is non-empty: `Access-Control-Allow-Origin` matches the request origin against the list
- If `allowed_origins` is empty: `Access-Control-Allow-Origin: *`
- Preflight `OPTIONS` is handled automatically by FastAPI/Starlette CORS middleware

### Script Isolation

`embed.js` is a standalone file with no dependencies on:
- The dashboard JavaScript files
- Any JavaScript framework (no React, Vue, jQuery)
- Any external CSS framework

It uses only browser-native APIs: `fetch()`, `document.createElement()`, `addEventListener()`, `URLSearchParams()`, `JSON.stringify()`.

## Consequences

### Positive
- **Universal compatibility:** Works on any website that can include a `<script>` tag -- WordPress, Squarespace, static HTML, SPAs, documentation sites.
- **Zero dependencies on host:** The embed script brings its own rendering logic. It does not require jQuery, React, or any specific CSS framework on the host page.
- **Dynamic form rendering:** The form is fetched as a schema, not baked into the HTML. This means changes to the form in the dashboard (field additions, label changes, A/B variants) take effect immediately without updating the embed code.
- **Transparent A/B testing:** The embed script does not know about experiments. It simply renders whatever schema the server returns. Variant selection happens server-side, and tracking fields are passed through transparently.
- **Field interaction analytics:** Built-in tracking of focus, blur, and fill events enables the field-level dropoff analysis in Module 4 without any additional analytics integration.
- **Attribution capture:** Automatic UTM parameter, referrer, and page URL capture enables the multi-touch attribution system without operator configuration.

### Negative
- **No SSR / SEO:** The form is rendered client-side via JavaScript. Search engines that do not execute JavaScript will not see the form. This is acceptable because forms are interactive elements, not content to be indexed.
- **Single point of failure:** If the FormAgent server is down, `embed.js` cannot fetch the schema and the form does not render. There is no offline fallback or cached form.
- **Style conflicts:** Even with scoped CSS, aggressive host page stylesheets (e.g., `* { margin: 0; }` or framework resets) may affect form appearance. The embed script must use sufficiently specific selectors.
- **Script blocking:** If the host page loads `embed.js` synchronously, it blocks page rendering until the script loads and the schema fetch completes. Using `async` or `defer` on the script tag mitigates this, but the embed snippet does not include these attributes by default.
- **Form ID exposure:** The form ID is visible in the page source. Anyone can submit to the form programmatically if they know the ID. Anti-spam measures (honeypot, rate limiting, CORS) mitigate abuse, but there is no cryptographic submission token.
- **No offline form fill:** The form requires a network connection both to render (schema fetch) and to submit. No service worker or local storage caching is implemented.

## Alternatives Considered

1. **iframe embed** - Serve the form as a full HTML page in an iframe. Rejected because: (a) iframe sizing and responsive behavior is problematic (height does not auto-adjust to form length); (b) cross-origin communication between iframe and host page is restricted; (c) iframes are blocked by some security policies; (d) UTM parameter and referrer capture from the parent page requires `postMessage` coordination.

2. **Web Component (Custom Element)** - Distribute the form as a `<fa-form>` custom element with Shadow DOM for style isolation. Considered as a future improvement. Rejected for MVP because: (a) adds complexity to the embed script; (b) Shadow DOM has edge cases in older browsers; (c) the style isolation benefit can be approximated with scoped class prefixes.

3. **Server-rendered HTML snippet** - The embed endpoint returns pre-rendered HTML, not a schema. The script tag simply injects the HTML. Rejected because: (a) A/B variants cannot be dynamically selected at render time (the HTML is static); (b) field interaction tracking still requires JavaScript; (c) form changes require re-fetching the HTML, negating any caching benefit.

4. **npm package / React component** - Distribute the form as an npm package (`@formagent/react`, `@formagent/vue`). Rejected because: (a) limits compatibility to specific frameworks; (b) requires the host site to have a build pipeline; (c) the script tag approach works everywhere including non-JS-framework sites.

5. **Google Forms / Typeform-style hosted page** - Instead of embedding, provide a hosted FormAgent URL that the operator links to. Rejected because: (a) takes visitors off the operator's domain, reducing trust and conversion; (b) loses the operator's page context (UTM params, page URL); (c) embedding is the expected UX for form products.
